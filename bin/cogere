#!/usr/bin/perl
use strict;
use warnings;
use lib '/opt/sv/lib';

use SV::Logger;
use Getopt::Long qw/:config no_ignore_case/;
use Net::OpenSSH;
use Switch;
use JSON;
use YAML::Tiny;
use List::MoreUtils qw/uniq/;

my $json_o = JSON->new->utf8;
my %log = ( 'user' => $ENV{'SUDO_USER'} );

open my $in_garb,  '<', '/dev/null';
open my $out_garb, '>', '/dev/null';
open my $err_garb, '>', '/dev/null';

my $def_base_dir = '/opt/sv/cogere';
my $base_dir     = $def_base_dir;
my $def_config   = "$base_dir/conf/cogere.conf";
my ($hosts_conf, $keys_dir, $genpass, $ssh_keygen,
    $ssh_copy_id, $username, $logger, $log_host,
    $log_port, $log_proto, $log_name);

if (!@ARGV) {
    help();
    exit;
}

my %args;
GetOptions(
    'h|help'        => \$args{'help'},
    'f|config'      => \$args{'config'},
    'l|host-list=s' => \$args{'host-list'},
    'r|reason=s'    => \$args{'reason'},
    'rekey-hosts'   => \$args{'rekey-hosts'},
    'add-host'      => \$args{'add-host'},
    'del-host'      => \$args{'del-host'},
    'hostname=s'    => \$args{'hostname'},
    'ipaddr=s'      => \$args{'ipaddr'},
    'username=s'    => \$args{'username'},
    'g|group=s'     => \$args{'group'},
    'add-group'     => \$args{'add-group'},
    'del-group'     => \$args{'del-group'},
    'join-group'    => \$args{'join-group'},
    'leave-group'   => \$args{'leave-group'},
    'lh|list-hosts'    => \$args{'list-hosts'},
    'lg|list-groups'   => \$args{'list-groups'},
    'lm|list-members'  => \$args{'list-members'},
    'a|all'         => \$args{'all'},
) or die "Invalid arguments. See $0 -h\n";

my $command = $ARGV[0];

if ($args{'config'}) {
    set_globals($args{'config'});
}
else {
    set_globals($def_config);
}

check_globals();
create_logger();

if ($args{'help'}) {
    help();
    exit;
}
elsif ($args{'list-hosts'}) {
    process_list_hosts();
    exit;
}
elsif ($args{'list-groups'}) {
    process_list_groups();
    exit;
}
elsif ($args{'list-members'}) {
    process_list_members($args{'group'});
    exit;
}

if ($args{'del-host'}) {
    process_del_host($args{'hostname'});
    exit;
}
elsif ($args{'add-host'}) {
    process_add_host($args{'hostname'}, $args{'ipaddr'}, $args{'username'});
    exit;
}
elsif ($args{'add-group'}) {
    process_add_group($args{'group'}, $args{'host-list'});
    exit;
}
elsif ($args{'del-group'}) {
    process_del_group($args{'group'});
    exit;
}
elsif ($args{'join-group'}) {
    process_join_group($args{'group'}, $args{'host-list'});
    exit;
}
elsif ($args{'leave-group'}) {
    process_leave_group($args{'group'}, $args{'host-list'});
    exit;
}

if ($args{'all'}) {
    process_all();
}   
elsif ($args{'group'}) {
    process_group($args{'group'})
}

if ($args{'rekey-hosts'}) {
    process_rekey_host($args{'host-list'});
    exit;
}

if ($args{'host-list'}) {
    process_host_list($args{'host-list'});
    exit;
}
else {
    die "No operations provided. See $0 -h.\n";
}

sub help {
    print <<EOH;
cogere -- verb: to collect/gather, to compel/force

Usage: cogere --reason 'report hostname' --host-list host1,host2 'hostname'

Operations:
  -l|--host-list  Comma separated hostname list, command is executed on hosts
                    if no other operations provided.
                    Requires --reason
  --add-host      Creates new host entry and keys remote host.
                    Requires --hostname, --ipaddr. Optionally --username
  --del-host      Removes host entry and remove key from remote host
                    Requires --hostname
  --rekey-hosts   Creates new SSH key, removes old SSH key and installs
                    new SSH key on remote host.
                    Requires --host-list
  -g|--group      Comma separated group list, command is executed on groups
                    if no other operations provided.
                    Requires --reason
  --add-group     Creates new group of hosts.
                    Requires --group, --host-list
  --del-group     Delete group.
                    Requires --group
  --join-group    Adds hosts to an existing group.
                    Requires --group, --host-list
  --leave-group   Remove hosts from an existing group.
                    Requires --group, --host-list

Options:
  -h|--help           Shows this output
  -f|--config         Alternate configuration file
  --hostname          Hostname to be provided to --add-host or --del-host
  --ipaddr            IP address to be provided to --add-host
  --username          User name to be provided to --add-host
                        Optional, 'cogere' is used by default
  -r|--reason         Explanation of the command you are running
  -a|--all            Builds a group of all defined hosts.
  --lh|--list-hosts   Displays all defined hosts
  --lg|--list-groups  Displays all defined groups
  --lm|--list-members Displays all hosts within group
                        Requires --group

John Shields - SmartVault Corporation - 2015
EOH
}

sub set_globals {
    my ($config) = @_;

    open my $config_h, '<', $config or die "Failed to open '$config': $!.\n";
    while (<$config_h>) {
        chomp;
        next if /^\s*#|^\s*$/;
        my ($var, $val) = split /=/;

        switch ($var) {
            case /^base_dir$/    { $base_dir    = $val }
            case /^hosts_conf$/  { $hosts_conf  = "$base_dir/$val" }
            case /^keys_dir$/    { $keys_dir    = "$base_dir/$val" }
            case /^genpass$/     { $genpass     = $val }
            case /^ssh_keygen$/  { $ssh_keygen  = $val }
            case /^ssh_copy_id$/ { $ssh_copy_id = $val }
            case /^username$/    { $username    = $val }
            case /^log_host$/    { $log_host    = $val }
            case /^log_port$/    { $log_port    = $val }
            case /^log_proto$/   { $log_proto   = $val }
            case /^log_name$/    { $log_name    = $val }
            else                 { warn "'$var' not recognized configuration parameter.\n" }
        }
    }
    
    return;
}

sub check_globals {
    $base_dir or die "Base directory not defined.\n";
    die "Base directory '$base_dir' not found.\n" if !-d $base_dir;

    $hosts_conf or die "Hosts configuration not defined.\n";
    if (!-f $hosts_conf) {
        open my $handle, '>', $hosts_conf
          or die "Failed to create empty hosts config '$hosts_conf'.\n";
        close $handle;
    }
    die "Hosts configuration '$hosts_conf' not found.\n" if !-f $hosts_conf;

    $keys_dir or die "Private keys directory not defined.\n";
    die "Keys directory '$keys_dir' not found.\n" if !-d $keys_dir;

    $genpass or die "genpass is not defined.\n";
    die "genpass '$genpass' is not executable.\n" if !-x $genpass;

    $ssh_keygen or die "ssh_keygen is not defined.\n";
    die "ssh-keygen '$ssh_keygen' is not executable.\n" if !-x $ssh_keygen;
    $ssh_copy_id or die "ssh_copy_id is not defined.\n";
    die "ssh-copy-id '$ssh_copy_id' is not executable.\n" if !-x $ssh_copy_id;

    $username  or die "Username is not defined.\n";
    $log_host  or die "Logging host is not defined.\n";
    $log_port  or die "Logging port is not defined.\n";
    $log_proto or die "Logging protocol is not defined.\n";
    $log_name  or die "Logging application name is not defined.\n";

    return;
}

sub create_logger {
    $logger = SV::Logger->new(
        'host'     => $log_host,
        'port'     => $log_port,
        'protocol' => $log_proto,
        'app'      => $log_name,
    );

    return;
}

sub get_yaml {
    my $yaml = YAML::Tiny->read($hosts_conf) or die "Failed to parse '$hosts_conf': $!.\n";

    return $yaml;
}

sub get_config {
    my $yaml = get_yaml();

    return $yaml->[0];
}

sub validate_hosts {
    my (@hosts) = @_;

    for my $host (@hosts) {
        get_host($host) or die "Invalid host '$host'.\n";
    }

    return;
}

sub validate_groups {
    my (@groups) = @_;

    for my $group (@groups) {
        get_members($group) or die "Invalid group '$group'.\n";
    }

    return;
}

sub get_host {
    my ($hostname) = @_;

    my $host;
    my $config = get_config();
    $host = $config->{'hosts'}{$hostname};

    return $host;
}

sub get_members {
    my ($group) = @_;

    my $config = get_config();
    my $mem_ref = $config->{'groups'}{$group};
    $mem_ref or die "Group '$group' not found.\n";

    my @members = @{$mem_ref};

    return @members;
}

sub get_params {
    my ($host) = @_;

    my $host_o = get_host($host);

    my %params = (
        'hostname' => $host,
        'username' => $host_o->{'username'},
        'ipaddr'   => $host_o->{'ipaddr'},
        'password' => $host_o->{'password'},
        'remoteid' => $host_o->{'remoteid'},
        'private'  => "$keys_dir/$host",
        'public'   => "$keys_dir/$host.pub",
    );

    return %params;
}

sub gen_key {
    my ($hostname) = @_;

    if (-e "$keys_dir/$hostname" or -e "$keys_dir/$hostname.pub") {
        die "Keys already exist.\n";
    }

    open my $handle, "$genpass -c2 -S0 -l32|" or die "Failed to generate password: $!.\n";
    chomp(my @lines = <$handle>);
    close $handle;

    my ($password, $remoteid) = @lines;

    `$ssh_keygen -q -b 4096 -t rsa -P "$password" -C "$remoteid" -f "$keys_dir/$hostname"`;
    die "Failed to generate SSH keys for '$hostname': $!.\n" if ($? > 0);

    chmod 0600, "$keys_dir/$hostname", "$keys_dir/$hostname.pub"
      or die "Failed to correct permissions on '$keys_dir/$hostname', '$keys_dir/$hostname.pub': $!.\n";

    return ($password, $remoteid);
}

sub copy_key {
    my ($hostname, $user, $ipaddr) = @_;
    
    my $out = `$ssh_copy_id -i "$keys_dir/$hostname" $user\@$ipaddr`;
    die "Failed to copy SSH key to remote host '$user\@$ipaddr': $out.\n" if ($? > 0);

    return;
}

sub add_hosts_conf {
    my ($hostname, $user, $ipaddr, $password, $remoteid) = @_;

    my $yaml = get_yaml();
    my $host = {
        'username' => $user,
        'ipaddr'   => $ipaddr,
        'password' => $password,
        'remoteid' => $remoteid,
    };
    $yaml->[0]{'hosts'}{$hostname} = $host;
    $yaml->write($hosts_conf);

    return;
}

sub del_hosts_conf {
    my ($hostname, $timestamp) = @_;

    my $yaml = get_yaml();
    delete $yaml->[0]{'hosts'}{$hostname};
    $yaml->write($hosts_conf);

    $hostname = "$hostname.$timestamp" if $timestamp;

    unlink "$keys_dir/$hostname"     or die "Failed to unlink '$keys_dir/$hostname': $!.\n";
    unlink "$keys_dir/$hostname.pub" or die "Failed to unlink '$keys_dir/$hostname.pub': $!.\n";

    return;
}

sub add_remote_key { 
    my ($hostname) = @_;

    my ($key, $handle);
    open $handle, '<', "$keys_dir/$hostname.pub" or die "Failed to open '$keys_dir/$hostname.pub': $!.\n";
    chomp($key = <$handle>);
    close $handle;

    my %params = get_params($hostname);
    $command = "echo '$key' >> /home/$params{'username'}/.ssh/authorized_keys";
    $args{'reason'} = "Adding SSH key to $hostname";

    return;
}

sub del_remote_key {
    my ($hostname, $remoteid) = @_;

    my %params = get_params($hostname);
    $params{'remoteid'} = $remoteid if $remoteid;
    $command = "sed -i '/$params{'remoteid'}\$/d' /home/$params{'username'}/.ssh/authorized_keys";
    $args{'reason'} = "Removing SSH key from $hostname";

    return;
}

sub backup_key {
    my ($hostname) = @_;

    my $timestamp = time;

    rename "$keys_dir/$hostname", "$keys_dir/$hostname.$timestamp"
      or die "Failed to backup '$keys_dir/$hostname': $!.\n";
    rename "$keys_dir/$hostname.pub", "$keys_dir/$hostname.$timestamp.pub"
      or die "Failed to backup '$keys_dir/$hostname.pub': $!.\n";

    return $timestamp;
}

sub process_host_list {
    my ($host_list, $timestamp) = @_;

    $host_list      or die "Host list was not provided.\n";
    $command        or die "Command was not provided.\n";
    $args{'reason'} or die "Reason was not provided.\n";

    my @dirty_hosts = split /,/, $host_list;
    my @hosts = uniq @dirty_hosts;
    validate_hosts(@hosts);

    $log{'hosts'}   = \@hosts;
    $log{'command'} = $command;
    $log{'message'} = $args{'reason'};

    $logger->write($json_o->encode(\%log));

    for my $hostname (@hosts) {
        my %params = get_params($hostname);
        if ($timestamp) {
            $params{'private'} = "$keys_dir/$hostname.$timestamp";
            $params{'public'}  = "$keys_dir/$hostname.$timestamp.pub";
        }
        my $ssh = Net::OpenSSH->new($params{'ipaddr'},
            'user'              => $params{'username'},
            'passphrase'        => $params{'password'},
            'key_path'          => $params{'private'},
            'default_stdout_fh' => $out_garb,
            'default_stderr_fh' => $err_garb,
            'default_stdin_fh'  => $in_garb,
        );
        $ssh->error and die "Failed to establish SSH connect: ${\$ssh->error}.\n";
        my ($out, $pid) = $ssh->pipe_out($command)
          or die "Failed to open command pipe ${\$ssh->error}.\n";
        print while <$out>;
        close $out;
    }

    return;
}

sub process_add_host {
    my ($hostname, $ipaddr, $user) = @_;

    $hostname or die "Failed to provide hostname.\n";
    $ipaddr   or die "Failed to provide IP address.\n";
    $user     = defined $user ? $user : $username;

    get_host($hostname) and die "Hostname '$hostname' already defined.\n";

    $log{'message'} = "Adding host '$hostname'";

    my ($password, $remoteid) = gen_key($hostname);
    copy_key($hostname, $user, $ipaddr);

    add_hosts_conf($hostname, $user, $ipaddr, $password, $remoteid);

    return;
}

sub process_del_host {
    my ($hostname) = @_;

    get_host($hostname) or die "Hostname '$hostname' not defined.\n";

    $log{'message'} = "Deleting host '$hostname'";
    $logger->write($json_o->encode(\%log));

    my %params = get_params($hostname);

    del_remote_key($hostname);
    process_host_list($hostname);
    del_hosts_conf($hostname);    

    return;
}

sub process_rekey_host {
    my ($host_list) = @_;

    my @dirty_hosts = split /,/, $host_list;
    my @hosts = uniq @dirty_hosts;
    for my $hostname (@hosts) {
        get_host($hostname) or die "Hostname '$hostname' not defined,\n";

        $log{'message'} = "Rekeying host '$hostname'";
        $logger->write($json_o->encode(\%log));

        my %params = get_params($hostname);

        my $timestamp = backup_key($hostname);
        my ($password, $remoteid) = gen_key($hostname);
        add_remote_key($hostname);
        process_host_list($hostname, $timestamp);
        del_hosts_conf($hostname, $timestamp);
        add_hosts_conf($hostname, $params{'username'}, $params{'ipaddr'}, $password, $remoteid);
        del_remote_key($hostname, $params{'remoteid'});
        process_host_list($hostname);
    }

    return;
}

sub process_list_hosts {
    my $config = get_config();

    my $hosts = $config->{'hosts'};
    for my $host (sort keys %{$hosts}) {
        print "$host\n";
    }

    return;
}

sub process_list_groups {
    my $config = get_config();

    my $groups = $config->{'groups'};
    for my $group (sort keys %{$groups}) {
        process_list_members($group);
    }

    return;
}

sub process_list_members {
    my ($group) = @_;

    $group or die "Group was not provided.\n";

    my $config = get_config();
    my $hosts = $config->{'groups'}{$group};
    
    $hosts or die "Group was not found\n";

    printf "%s - %s\n", $group, join ',',@{$hosts};

    return;
}

sub process_add_group {
    my ($group, $host_list) = @_;

    $group or die "Group was not provided.\n";
    $host_list or die "Failed to provided host list.\n";

    my $yaml = get_yaml();

    if (exists $yaml->[0]{'groups'}{$group}) {
        die "Group '$group' exists, cannot recreate. Join or delete '$group'.\n";
    }

    my @dirty_hosts = split /,/, $host_list;
    my @hosts = uniq @dirty_hosts;
    validate_hosts(@hosts);

    $yaml->[0]{'groups'}{$group} = \@hosts;
    $yaml->write($hosts_conf);

    return;
}

sub process_del_group {
    my ($group) = @_;

    $group or die "Group was not provided.\n";

    my $yaml = get_yaml();
    if (!exists $yaml->[0]{'groups'}{$group}) {
        die "Group '$group' does not exist, cannot delete.\n";
    }

    delete $yaml->[0]{'groups'}{$group};
    $yaml->write($hosts_conf);

    return;
}

sub process_join_group {
    my ($group, $host_list) = @_;

    $group or die "Group was not provided.\n";
    $host_list or die "Host list was not provided.\n";
    my @dirty_hosts = split /,/, $host_list;
    my @hosts = uniq @dirty_hosts;

    validate_groups($group);
    validate_hosts(@hosts);

    my @members = get_members($group);
    push @members, @hosts;

    my $yaml = get_yaml();
    $yaml->[0]{'groups'}{$group} = \@members;
    $yaml->write($hosts_conf);

    return;
}

sub process_leave_group {
    my ($group, $host_list) = @_;

    $group or die "Group was not provided.\n";
    $host_list or die "Host list was not provided.\n";
    my @dirty_hosts = split /,/, $host_list;
    my @hosts = uniq @dirty_hosts;

    validate_groups($group);
    validate_hosts(@hosts);

    my @members = get_members($group);
    
    for my $host (@hosts) {
        @members = grep { $_ ne $host } @members;
    }

    my $yaml = get_yaml();
    $yaml->[0]{'groups'}{$group} = \@members;
    $yaml->write($hosts_conf);

    return;
}

sub process_group {
    my ($group_list) = @_;

    $group_list or die "Groups were not provided.\n";
    my @dirty_groups = split /,/, $group_list;
    my @groups = uniq @dirty_groups;

    #validate_groups(@groups);

    my @hosts;
    for my $group (@groups) {
        my @members = get_members($group);
        push @hosts, @members;
    }

    $args{'host-list'} = join ',', @hosts;

    return;
}

sub process_all {
    my $config = get_config();

    my $hosts_ref = $config->{'hosts'};
    my @hosts;
    for my $host (sort keys %{$hosts_ref}) {
        push @hosts, $host;
    }

    $args{'host-list'} = join ',', @hosts;

    return;
}
