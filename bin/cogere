#!/usr/bin/perl
#: Author  : John Shields <john.shields@smartvault.com>
#: Name    : cogere.pl
#: Version : 1.6.0
#: Path    : /opt/sv/bin/cogere
#: Params  : see --help
#: Desc    : Broadcasts commands to select hosts over SSH
#: License :
# Copyright (c) 2015 SmartVault, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/../lib";
use SV::Logger;
use Getopt::Long qw/:config no_ignore_case/;
use Net::OpenSSH;
use Switch;
use JSON;
use YAML::Tiny;
use List::MoreUtils qw/uniq/;
use POSIX qw/strftime/;
use Parallel::ForkManager;
use File::Copy qw/copy/;

die "Not being ran from sudo!\n" if !$ENV{'SUDO_USER'};

my $json_o = JSON->new->utf8;
my %log = ( 'user' => $ENV{'SUDO_USER'} );

my $def_base_dir = '/opt/sv/cogere';
my $base_dir     = $def_base_dir;
my $def_config   = "$base_dir/conf/cogere.conf";
my (
    $hosts_conf, $keys_dir, $genpass,  $ssh_keygen, $ssh_copy_id, $username, $log_type,
    $logstash,   $log_file, $log_host, $log_port,   $log_proto,   $log_name, $default_key,
);

if ( !@ARGV ) {
    help();
    exit;
}

my %args;
GetOptions(
    'help'           => \$args{'help'},
    'f|config'       => \$args{'config'},
    'h|host=s@'      => \$args{'host'},
    'r|reason=s'     => \$args{'reason'},
    'rekey-hosts'    => \$args{'rekey-hosts'},
    'add-host'       => \$args{'add-host'},
    'del-host'       => \$args{'del-host'},
    'hostname=s'     => \$args{'hostname'},
    'ipaddr=s'       => \$args{'ipaddr'},
    'username=s'     => \$args{'username'},
    'g|group=s@'     => \$args{'group'},
    'add-group'      => \$args{'add-group'},
    'del-group'      => \$args{'del-group'},
    'join-group'     => \$args{'join-group'},
    'leave-group'    => \$args{'leave-group'},
    'H|list-hosts'   => \$args{'list-hosts'},
    'G|list-groups'  => \$args{'list-groups'},
    'M|list-members' => \$args{'list-members'},
    'a|all'          => \$args{'all'},
    'F|fork=s'       => \$args{'fork'},
    's|scp-source=s' => \$args{'scp-source'},
    't|scp-target=s' => \$args{'scp-target'},
    'scp-only'       => \$args{'scp-only'},
    'default-key'    => \$args{'default-key'},
    'new-default'    => \$args{'new-default'},
    'show-default'   => \$args{'show-default'},
    'cleanup'        => \$args{'cleanup'},
    'command-file=s' => \$args{'command-file'},
) or die "Invalid arguments. See $0 --help\n";

my @target_hosts;
my @negate_hosts;
my @commands = @ARGV;
my $fork_num = $args{'fork'};

if ( $args{'config'} ) {
    set_globals( $args{'config'} );
}
else {
    set_globals($def_config);
}

check_globals();

if ( $args{'help'} ) {
    help();
    exit;
}

if ( $args{'list-hosts'} ) {
    process_list_hosts();
    exit;
}
if ( $args{'list-groups'} ) {
    process_list_groups();
    exit;
}
if ( $args{'list-members'} ) {
    process_list_members( $args{'group'} );
    exit;
}

if ( $args{'show-default'} ) {
    process_show_default();
    exit;
}

if ( $args{'add-host'} ) {
    process_add_host( $args{'hostname'}, $args{'ipaddr'}, $args{'username'},
      $args{'default-key'}, $args{'group'} );
    exit;
}
if ( $args{'del-host'} ) {
    process_del_host( $args{'hostname'} );
    exit;
}
if ( $args{'add-group'} ) {
    process_add_group( $args{'group'}, $args{'host'} );
    exit;
}
if ( $args{'del-group'} ) {
    process_del_group( $args{'group'} );
    exit;
}
if ( $args{'join-group'} ) {
    process_join_group( $args{'group'}, $args{'host'} );
    exit;
}
if ( $args{'leave-group'} ) {
    process_leave_group( $args{'group'}, $args{'host'} );
    exit;
}
if ( $args{'cleanup'} ) {
    process_cleanup( $args{'hostname'} );
    exit;
}

if ( $args{'new-default'} ) {
    process_new_default();
    exit;
}

if ( $args{'all'} ) {
    process_all();
}
if ( $args{'group'} ) {
    process_group( $args{'group'} );
}
if ( $args{'host'} ) {
    process_host( $args{'host'} );
}

process_negate();
remove_default();

if ( $args{'rekey-hosts'} ) {
    process_rekey_host( [@target_hosts] );
    exit;
}

if ( $args{'scp-source'} and $args{'scp-target'} and $args{'scp-only'} ) {
    @commands = ("scp $args{'scp-source'} $args{'scp-target'}");
}

if ( $args{'command-file'} ) {
    process_command_file( $args{'command-file'} );
}

if (@target_hosts) {
    process_host_list( [@target_hosts], 0,
      $args{'scp-source'}, $args{'scp-target'}, $args{'scp-only'} );
    exit;
}
else {
    die "No hosts or operations provided. See $0 --help.\n";
}

sub help {
    print <<EOH;
cogere -- verb: to collect/gather, to compel/force

Usage: cogere --reason 'report hostname' --host host1 --host host2 'hostname'

Operations:
  -h|--host       Host to connect to, can be provided multiple times. Commands
                    are executed on hosts if no other operations provided.
                    Requires -r|--reason
  --add-host      Creates new host entry and keys remote host.
                    Requires --hostname, --ipaddr. Optionally --username
                    Optionally can use --default-key to connect using
                    default SSH key rather than password authentication
  --del-host      Removes host entry and remove key from remote host
                    Requires --hostname
  --rekey-hosts   Creates new SSH key, removes old SSH key and installs
                    new SSH key on remote host.
                    Requires -h|--host
  -g|--group      Group to connect to, can be provided multiple times. Commands
                    are executed on groups if no other operations provided.
                    Requires -r|--reason
  --add-group     Creates new group of hosts.
                    Requires -g|--group, -h|--host
  --del-group     Delete group.
                    Requires -g|--group
  --join-group    Adds hosts to an existing group.
                    Requires -g|--group, -h|--host
  --leave-group   Remove hosts from an existing group.
                    Requires -g|--group, -h|--host

Options:
  --help              Shows this output
  -f|--config         Alternate configuration file
  --hostname          Hostname to be provided to --add-host or --del-host
  --ipaddr            IP address to be provided to --add-host
  --username          User name to be provided to --add-host
                        Optional, 'cogere' is used by default
  -r|--reason         Explanation of the commands you are running
  -a|--all            Builds a group of all defined hosts.
  -F|--fork           Forks supplied number of connections and waits for them
                        to complete, the continues. The keywords 'a' or 'all'
                        will produce a fork number equal to the number of
                        hosts supplied
  -H|--list-hosts     Displays all defined hosts
  -G|--list-groups    Displays all defined groups
  -M|--list-members   Displays all hosts within group
                        Requires -g|--group
  --command-file      Execute commands provided by command-file
  -s|--scp-source     Performs an scp on local file or directory
                        Requires -t|--scp-target
  -t|--scp-target     Performs an scp to target remote directory
                        Requires -s|--scp-file
  --scp-only          Only copy files to remote hosts
  --default-key       Uses the default SSH key rather than password
                        when adding host
  --new-default       Create a new default SSH key
  --show-default      Prints the default public key
  --cleanup           Removes all entries for supplied host
                        Requires --hostname

Notes:
  Host and group negation:
    Hosts and groups can be negated by prefixing them with ':'
  Mulitple commands:
    Multiple commands can be specified as arguments, they will
    be ran in sequence

John Shields - SmartVault Corporation - 2015
EOH
}

sub set_globals {
    my ($config) = @_;

    open my $config_h, '<', $config or die "Failed to open '$config': $!.\n";
    while (<$config_h>) {
        chomp;
        next if /^\s*#|^\s*$/;
        my ( $var, $val ) = split /=/;

        switch ($var) {
            case /^base_dir$/    { $base_dir    = $val }
            case /^hosts_conf$/  { $hosts_conf  = "$base_dir/$val" }
            case /^keys_dir$/    { $keys_dir    = "$base_dir/$val" }
            case /^genpass$/     { $genpass     = $val }
            case /^ssh_keygen$/  { $ssh_keygen  = $val }
            case /^ssh_copy_id$/ { $ssh_copy_id = $val }
            case /^username$/    { $username    = $val }
            case /^log_type$/    { $log_type    = $val }
            case /^log_host$/    { $log_host    = $val }
            case /^log_port$/    { $log_port    = $val }
            case /^log_proto$/   { $log_proto   = $val }
            case /^log_name$/    { $log_name    = $val }
            case /^log_file$/    { $log_file    = $val }
            case /^default_key$/ { $default_key = $val }
            else                 { warn "'$var' not recognized configuration parameter.\n" }
        }
    }

    return;
}

sub check_globals {
    $base_dir or die "Base directory not defined.\n";
    die "Base directory '$base_dir' not found.\n" if !-d $base_dir;

    $hosts_conf or die "Hosts configuration not defined.\n";
    if ( !-f $hosts_conf ) {
        open my $handle, '>', $hosts_conf
          or die "Failed to create empty hosts config '$hosts_conf'.\n";
        close $handle;
    }
    die "Hosts configuration '$hosts_conf' not found.\n" if !-f $hosts_conf;

    $keys_dir or die "Private keys directory not defined.\n";
    die "Keys directory '$keys_dir' not found.\n" if !-d $keys_dir;

    $genpass or die "genpass is not defined.\n";
    die "genpass '$genpass' is not executable.\n" if !-x $genpass;

    $ssh_keygen or die "ssh_keygen is not defined.\n";
    die "ssh-keygen '$ssh_keygen' is not executable.\n" if !-x $ssh_keygen;
    $ssh_copy_id or die "ssh_copy_id is not defined.\n";
    die "ssh-copy-id '$ssh_copy_id' is not executable.\n" if !-x $ssh_copy_id;

    $username or die "Username is not defined.\n";

    $log_type or die "Logging type(s) not defined\n";
    my @log_types = split /,/, $log_type;
    for my $log (@log_types) {
        switch ($log) {
            case /^logstash$/ {
                $log_host  or die "Logging host is not defined.\n";
                $log_port  or die "Logging port is not defined.\n";
                $log_proto or die "Logging protocol is not defined.\n";
                $log_name  or die "Logging application name is not defined.\n";
                $logstash = 1;
            }
            case /^file$/ {
                $log_file or die "Log file is not defined.\n";
                die "Log file '$log_file' not found.\n" if !-f $log_file;
            }
            else {
                die "Invalied log type '$log'.\n";
            }
        }
    }

    return;
}

sub write_log {
    my %log = @_;

    if ($log_file) {
        my $timestamp = strftime "%Y-%m-%d %H:%M:%S", localtime;

        open my $handle, '>>', $log_file
          or die "Failed to open '$log_file': $!.\n";
        printf $handle "%s\nTime:     %s\nUser:     %s\nHosts:    %s\nReason:   %s\nCommands:\n%s\n",
          '#' x 80, $timestamp, $log{'user'}, join( ',', @{ $log{'hosts'} } ), $log{'message'},
          join( "\n", @{ $log{'commands'} } );
        close $handle;

    }

    if ($logstash) {
        my $logger = SV::Logger->new(
            'host'     => $log_host,
            'port'     => $log_port,
            'protocol' => $log_proto,
            'app'      => $log_name,
        );
        $logger->write( $json_o->encode( \%log ) );
    }

    return;
}

sub get_yaml {
    my $yaml = YAML::Tiny->read($hosts_conf) or die "Failed to parse '$hosts_conf': $!.\n";

    return $yaml;
}

sub get_config {
    my $yaml = get_yaml();

    return $yaml->[0];
}

sub validate_hosts {
    my @hosts = @_;

    for my $host (@hosts) {
        get_host($host) or die "Invalid host '$host'.\n";
    }

    return;
}

sub validate_groups {
    my @groups = @_;

    for my $group (@groups) {
        get_members($group) or die "Invalid group '$group'.\n";
    }

    return;
}

sub get_host {
    my ($hostname) = @_;

    my $host;
    my $config = get_config();
    $host = $config->{'hosts'}{$hostname};

    return $host;
}

sub get_members {
    my ($group) = @_;

    my $config  = get_config();
    my $mem_ref = $config->{'groups'}{$group};
    $mem_ref or die "Group '$group' not found.\n";

    my @members = @{$mem_ref};

    return @members;
}

sub get_params {
    my ($host) = @_;

    my $host_o = get_host($host);

    my %params = (
        'hostname' => $host,
        'username' => $host_o->{'username'},
        'ipaddr'   => $host_o->{'ipaddr'},
        'password' => $host_o->{'password'},
        'remoteid' => $host_o->{'remoteid'},
        'private'  => "$keys_dir/$host",
        'public'   => "$keys_dir/$host.pub",
    );

    return %params;
}

sub gen_key {
    my ($hostname) = @_;

    if ( -e "$keys_dir/$hostname" or -e "$keys_dir/$hostname.pub" ) {
        die "Keys already exist.\n";
    }

    open my $handle, "$genpass -c2 -S0 -l32|" or die "Failed to generate password: $!.\n";
    chomp( my @lines = <$handle> );
    close $handle;

    my ( $password, $remoteid ) = @lines;

    `$ssh_keygen -q -b 4096 -t rsa -P "$password" -C "$remoteid" -f "$keys_dir/$hostname"`;
    die "Failed to generate SSH keys for '$hostname': $!.\n" if ( $? > 0 );

    chmod 0600, "$keys_dir/$hostname", "$keys_dir/$hostname.pub"
      or die "Failed to correct permissions on '$keys_dir/$hostname', '$keys_dir/$hostname.pub': $!.\n";

    return ( $password, $remoteid );
}

sub copy_key {
    my ( $hostname, $user, $ipaddr ) = @_;

    $log{'message'} = "Adding host '$hostname'";
    $log{'hosts'}   = [$hostname];
    $log{'commands'} = "[local] $ssh_copy_id -i \"$keys_dir/$hostname\" $user\@$ipaddr";
    write_log(%log);

    my $out = `$ssh_copy_id -i "$keys_dir/$hostname" $user\@$ipaddr`;

    if ( $? > 0 ) {
        warn "Failed to copy SSH key to remote host '$user\@$ipaddr': $out.\n";
        return 1;
    }

    return;
}

sub add_hosts_conf {
    my ( $hostname, $user, $ipaddr, $password, $remoteid ) = @_;

    my $yaml = get_yaml();
    my $host = {
        'username' => $user,
        'ipaddr'   => $ipaddr,
        'password' => $password,
        'remoteid' => $remoteid,
    };
    $yaml->[0]{'hosts'}{$hostname} = $host;
    $yaml->write($hosts_conf);

    return;
}

sub del_hosts_conf {
    my ( $hostname, $timestamp ) = @_;

    my $yaml = get_yaml();
    delete $yaml->[0]{'hosts'}{$hostname};
    $yaml->write($hosts_conf);

    $hostname = "$hostname.$timestamp" if $timestamp;

    if ( -f "$keys_dir/$hostname" ) {
        unlink "$keys_dir/$hostname"
          or die "Failed to unlink '$keys_dir/$hostname': $!.\n";
    }

    if ( -f "$keys_dir/$hostname.pub" ) {
        unlink "$keys_dir/$hostname.pub"
          or die "Failed to unlink '$keys_dir/$hostname.pub': $!.\n";
    }

    return;
}

sub add_remote_key {
    my ($hostname) = @_;

    my ( $key, $handle );
    open $handle, '<', "$keys_dir/$hostname.pub" or die "Failed to open '$keys_dir/$hostname.pub': $!.\n";
    chomp( $key = <$handle> );
    close $handle;

    my %params = get_params($hostname);
    @commands = ("echo '$key' >> /home/$params{'username'}/.ssh/authorized_keys");
    $args{'reason'} = "Adding SSH key to $hostname";

    return;
}

sub del_remote_key {
    my ( $hostname, $remoteid ) = @_;

    my %params = get_params($hostname);
    $params{'remoteid'} = $remoteid if $remoteid;
    @commands           = ("sed -i '/$params{'remoteid'}\$/d' /home/$params{'username'}/.ssh/authorized_keys");
    $args{'reason'}     = "Removing SSH key from $hostname";

    return;
}

sub backup_key {
    my ($hostname) = @_;

    my $timestamp = time;

    rename "$keys_dir/$hostname", "$keys_dir/$hostname.$timestamp"
      or die "Failed to backup '$keys_dir/$hostname': $!.\n";
    rename "$keys_dir/$hostname.pub", "$keys_dir/$hostname.$timestamp.pub"
      or die "Failed to backup '$keys_dir/$hostname.pub': $!.\n";

    return $timestamp;
}

sub leave_all_groups {
    my ($host) = @_;

    my $config = get_config();
    for my $group ( keys %{ $config->{'groups'} } ) {
        my @members = get_members($group);
        if ( grep { $_ eq $host } @members ) {
            process_leave_group( [$group], [$host] );
        }
    }

    return;
}

sub open_ssh {
    my ( $hostname, %params ) = @_;

    open my $in_garb,  '<', '/dev/null';
    open my $out_garb, '>', '/dev/null';
    open my $err_garb, '>', '/dev/null';

    my $ssh = Net::OpenSSH->new(
        $params{'ipaddr'},
        'user'              => $params{'username'},
        'passphrase'        => $params{'password'},
        'key_path'          => $params{'private'},
        'default_stdout_fh' => $out_garb,
        'default_stderr_fh' => $err_garb,
        'default_stdin_fh'  => $in_garb,
    );

    if ( $ssh->error ) {
        warn "Failed to SSH to '$hostname': ${\$ssh->error}.\n";
        return 1;
    }

    return $ssh;
}

sub run_commands {
    my ( $hostname, $timestamp, $scp_source, $scp_target, $scp_only ) = @_;

    my %params = get_params($hostname);
    if ($timestamp) {
        $params{'private'} = "$keys_dir/$hostname.$timestamp";
        $params{'public'}  = "$keys_dir/$hostname.$timestamp.pub";
    }

    my $ssh = open_ssh( $hostname, %params );
    return 1 if $ssh == 1;

    if ( $scp_source and $scp_target ) {
        my $copy_failed = perform_scp( $scp_source, $scp_target, $ssh );
        if ($copy_failed) {
            warn "Failed to copy source to '$hostname'.\n";
            return 1;
        }

        if ($scp_only) {
            print "Successfully copied '$scp_source' to '$scp_target' to '$hostname'\n";
            return;
        }
    }

    for my $command (@commands) {
        my ( $out, $pid ) = $ssh->open2pty($command);

        if ( $ssh->error ) {
            warn "Failed to open command pipe on '$hostname': ${\$ssh->error}.\n";
            return 1;
        }

        if   ($fork_num) { print "[$hostname] $_" while <$out> }
        else             { print                  while <$out> }
        close $out;
    }

    return;
}

sub fork_hosts {
    my ( $hosts, $timestamp, $scp_file, $scp_target ) = @_;

    my $pm = Parallel::ForkManager->new($fork_num);
  HOSTS:
    for my $hostname ( @{$hosts} ) {
        $pm->start and next HOSTS;

        run_commands( $hostname, $timestamp, $scp_file, $scp_target );

        $pm->finish;
    }
    $pm->wait_all_children;

    return;
}

sub perform_scp {
    my ( $source, $target, $ssh ) = @_;

    if ( !-d $source and !-f $source ) {
        warn "Cannot copy '$source', source is neither a file nor a directory.\n";
        return 1;
    }

    $ssh->scp_put( { 'recursive' => 1 }, $source, $target );

    if ( $ssh->error ) {
        warn "Failed to copy source '$source': ${\$ssh->error}.\n";
        return 1;
    }

    return;
}

sub process_host_list {
    my ( $host_list, $timestamp, $scp_file, $scp_target, $scp_only ) = @_;

    $timestamp = 0 if !$timestamp;

    $host_list      or die "Host list was not provided.\n";
    @commands       or die "Commands were not provided.\n";
    $args{'reason'} or die "Reason was not provided.\n";

    my @dirty_hosts = @{$host_list};
    my @hosts       = uniq @dirty_hosts;
    validate_hosts(@hosts);

    $log{'hosts'}    = [@hosts];
    $log{'commands'} = [@commands];
    $log{'message'} = $args{'reason'} unless defined $log{'message'};

    write_log(%log);

    if ($fork_num) {
        if ( $fork_num =~ /^(a|all)$/ ) {
            $fork_num = $#hosts + 1;
        }
        elsif ( $fork_num !~ /\d+/ ) {
            die "Fork argument '$fork_num' is invalid\n";
        }
        fork_hosts( [@hosts], $timestamp, $scp_file, $scp_target, $scp_only );
    }
    else {
        for my $hostname (@hosts) {
            run_commands( $hostname, $timestamp, $scp_file, $scp_target, $scp_only );
        }
    }

    return;
}

sub process_add_host {
    my ( $hostname, $ipaddr, $user, $default, $group ) = @_;

    $hostname or die "Failed to provide hostname.\n";
    $ipaddr   or die "Failed to provide IP address.\n";
    $user     = defined $user ? $user : $username;

    my @groups;
    if ($group) {
        my @dirty_groups = @{$group};
        @groups       = uniq @dirty_groups;
        validate_groups(@groups);
    }

    get_host($hostname) and die "Hostname '$hostname' already defined.\n";

    $log{'message'} = "Adding host '$hostname'";

    if ( !$default ) {
        my ( $password, $remoteid ) = gen_key($hostname);
        my $failure = copy_key( $hostname, $user, $ipaddr );

        if ($failure) {
            process_cleanup($hostname);
            return 1;
        }
        
        add_hosts_conf( $hostname, $user, $ipaddr, $password, $remoteid );
    }
    else {
        my %def = get_params($default_key);
        add_hosts_conf( $hostname, $user, $ipaddr, $def{'password'}, $def{'remoteid'} );
        my $failure = key_from_default($hostname);
        
        if ($failure) {
            process_cleanup($hostname);
            return 1;
        }
    }

    print "Successfully added '$hostname'\n";

    if (@groups) {
        process_join_group( [@groups], [$hostname] );
    }

    return;
}

sub process_del_host {
    my ($hostname) = @_;

    get_host($hostname) or die "Hostname '$hostname' not defined.\n";

    $log{'message'} = "Deleting host '$hostname'";

    my %params = get_params($hostname);

    leave_all_groups($hostname);
    del_remote_key($hostname);
    process_host_list( [$hostname] );
    del_hosts_conf($hostname);

    print "Successfully deleted '$hostname'\n";

    return;
}

sub process_rekey_host {
    my ($host_list) = @_;

    my @dirty_hosts = @{$host_list};
    my @hosts       = uniq @dirty_hosts;
    validate_hosts(@hosts);

    for my $hostname (@hosts) {
        get_host($hostname) or die "Hostname '$hostname' not defined,\n";

        $log{'message'} = "Rekeying host '$hostname'";

        my %params = get_params($hostname);

        my $timestamp = backup_key($hostname);
        my ( $password, $remoteid ) = gen_key($hostname);
        add_remote_key($hostname);
        process_host_list( [$hostname], $timestamp );
        del_hosts_conf( $hostname, $timestamp );
        add_hosts_conf( $hostname, $params{'username'}, $params{'ipaddr'}, $password, $remoteid );
        del_remote_key( $hostname, $params{'remoteid'} );
        process_host_list( [$hostname] );

        print "Successfully rekeyed '$hostname'\n";
    }

    return;
}

sub process_list_hosts {
    my $config = get_config();

    my $hosts = $config->{'hosts'};
    for my $host ( sort keys %{$hosts} ) {
        next if $host eq $default_key;
        print "$host\n";
    }

    return;
}

sub process_list_groups {
    my $config = get_config();

    my $groups = $config->{'groups'};
    for my $group ( sort keys %{$groups} ) {
        process_list_members($group);
    }

    return;
}

sub process_list_members {
    my ($group) = @_;

    $group or die "Group was not provided.\n";

    my $config = get_config();
    my $hosts  = $config->{'groups'}{$group};

    $hosts or die "Group was not found\n";

    printf "%s - %s\n", $group, join ',', @{$hosts};

    return;
}

sub process_add_group {
    my ( $group, $host_list ) = @_;

    $group     or die "Group was not provided.\n";
    $host_list or die "Failed to provided host list.\n";

    my @dirty_groups = @{$group};
    my @groups       = uniq @dirty_groups;
    my @dirty_hosts  = @{$host_list};
    my @hosts        = uniq @dirty_hosts;
    validate_hosts(@hosts);

    my $yaml = get_yaml();

    for my $group (@groups) {
        if ( exists $yaml->[0]{'groups'}{$group} ) {
            warn "Group '$group' exists, cannot recreate. Join or delete '$group'.\n";
            next;
        }

        $yaml->[0]{'groups'}{$group} = [@hosts];
    }

    $yaml->write($hosts_conf);
    printf "Successfully created groups: '%s' with hosts: '%s'\n",
      join( ',', @groups ), join( ',', @hosts );

    return;
}

sub process_del_group {
    my ($group) = @_;

    $group or die "Group was not provided.\n";
    my @dirty_groups = @{$group};
    my @groups       = uniq @dirty_groups;
    validate_groups(@groups);

    my $yaml = get_yaml();

    for my $group (@groups) {
        if ( !exists $yaml->[0]{'groups'}{$group} ) {
            warn "Group '$group' does not exist, cannot delete.\n";
        }

        delete $yaml->[0]{'groups'}{$group};
    }

    $yaml->write($hosts_conf);
    printf "Successfully removed groups: '%s'\n",
      join( ',', @groups );

    return;
}

sub process_join_group {
    my ( $group, $host_list ) = @_;

    $group     or die "Group was not provided.\n";
    $host_list or die "Host list was not provided.\n";

    my @dirty_groups = @{$group};
    my @groups       = uniq @dirty_groups;
    my @dirty_hosts  = @{$host_list};
    my @hosts        = uniq @dirty_hosts;

    validate_groups(@groups);
    validate_hosts(@hosts);

    my $yaml = get_yaml();

    for my $group (@groups) {
        my @members = get_members($group);

        for my $host (@hosts) {
            next if grep { $_ eq $host } @members;
            push @members, $host;
        }

        $yaml->[0]{'groups'}{$group} = [@members];

    }

    $yaml->write($hosts_conf);
    printf "Successfully added hosts: '%s' to groups: '%s'\n",
      join( ',', @hosts ), join( ',', @groups );

    return;
}

sub process_leave_group {
    my ( $group, $host_list ) = @_;

    $group     or die "Group was not provided.\n";
    $host_list or die "Host list was not provided.\n";

    my @dirty_groups = @{$group};
    my @groups       = uniq @dirty_groups;
    my @dirty_hosts  = @{$host_list};
    my @hosts        = uniq @dirty_hosts;

    validate_groups(@groups);
    validate_hosts(@hosts);

    my $yaml = get_yaml();

    for my $group (@groups) {
        my @members = get_members($group);

        for my $host (@hosts) {
            @members = grep { $_ ne $host } @members;
        }

        $yaml->[0]{'groups'}{$group} = [@members];

        delete $yaml->[0]{'groups'}{$group}
          if !scalar @{ $yaml->[0]{'groups'}{$group} };
    }

    $yaml->write($hosts_conf);
    printf "Successfully removed hosts: '%s' from groups: '%s'\n",
      join( ',', @hosts ), join( ',', @groups );

    return;
}

sub process_host {
    my ($host_list) = @_;

    $host_list or return;

    my @dirty_hosts = @{$host_list};
    my @hosts       = uniq @dirty_hosts;

    for my $host (@hosts) {
        if ( $host =~ /^:/ ) {
            $host =~ s/^://;
            push @negate_hosts, $host;
        }
        else {
            push @target_hosts, $host;
        }
    }

    return;
}

sub process_group {
    my ($group_list) = @_;

    $group_list or die "Groups were not provided.\n";
    my @dirty_groups = @{$group_list};
    my @groups       = uniq @dirty_groups;

    for my $group (@groups) {
        if ( $group =~ /^:/ ) {
            $group =~ s/^://;
            my @members = get_members($group);
            @negate_hosts = ( @negate_hosts, @members );
        }
        else {
            my @members = get_members($group);
            @target_hosts = ( @target_hosts, @members );
        }
    }

    return;
}

sub process_all {
    my $config = get_config();

    my $hosts_ref = $config->{'hosts'};
    my @hosts;
    for my $host ( sort keys %{$hosts_ref} ) {
        push @hosts, $host;
    }

    @target_hosts = ( @target_hosts, @hosts );

    return;
}

sub process_negate {
    for my $host (@negate_hosts) {
        @target_hosts = grep { $_ ne $host } @target_hosts;
    }

    return;
}

sub process_show_default {
    if ( !-f "$keys_dir/$default_key" or !-f "$keys_dir/$default_key.pub" ) {
        die "No default key found\n";
    }

    open my $key_h, '<', "$keys_dir/$default_key.pub"
      or die "Failed to open '$keys_dir/$default_key.pub': $!\n";
    print while <$key_h>;
    close $key_h;

    return;
}

sub process_new_default {
    if ( -f "$keys_dir/$default_key" ) {
        unlink "$keys_dir/$default_key"
          or die "Failed to remote default private key: $!\n";
    }

    if ( -f "$keys_dir/$default_key.pub" ) {
        unlink "$keys_dir/$default_key.pub"
          or die "Failed to remove default public key: $!\n";
    }

    my ( $password, $remoteid ) = gen_key($default_key);
    add_hosts_conf( $default_key, 'default', '0.0.0.0', $password, $remoteid );

    process_show_default();

    return;
}

sub copy_default_key {
    my ($hostname) = @_;

    copy "$keys_dir/$default_key", "$keys_dir/$hostname"
      or die "Failed to copy default private key: $!\n";

    copy "$keys_dir/$default_key.pub", "$keys_dir/$hostname.pub"
      or die "Failed to copy default public key: $!\n";

    chmod 0600, "$keys_dir/$hostname", "$keys_dir/$hostname.pub"
      or die "Failed to correct permissions on '$keys_dir/$hostname', '$keys_dir/$hostname.pub': $!.\n";

    return;
}

sub key_from_default {
    my ($hostname) = @_;

    my %params = get_params($hostname);
    my %def    = get_params($default_key);

    $log{'message'} = "Adding host '$hostname' using default key";

    copy_default_key($hostname);
    my $timestamp = backup_key($hostname);
    my ( $password, $remoteid ) = gen_key($hostname);
    add_remote_key($hostname);
    process_host_list( [$hostname], $timestamp );
    del_hosts_conf( $hostname, $timestamp );
    add_hosts_conf( $hostname, $params{'username'}, $params{'ipaddr'}, $password, $remoteid );
    del_remote_key( $hostname, $def{'remoteid'} );
    process_host_list( [$hostname] );

    return;
}

sub remove_default {
    @target_hosts = grep { $_ ne $default_key } @target_hosts;

    return;
}

sub process_cleanup {
    my ($hostname) = @_;

    $hostname or die "Failed to provide hostname.\n";

    leave_all_groups($hostname);
    del_hosts_conf($hostname);

    return;
}

sub process_command_file {
    my ($command_file) = @_;

    open my $command_h, '<', $command_file
      or die "Failed to open '$command_file': $!\n";
    @commands = <$command_h>;
    close $command_h;

    chomp @commands;

    return;
}

